Action â†’ what happened
Reducer â†’ how state changes
Store â†’ where state lives


ğŸ”„ The Redux Cycle (MEMORIZE THIS)
UI
 â†“ dispatch
Action
 â†“
Reducer
 â†“
Store (new state)
 â†“
UI re-renders



ğŸ”„ Correct flow 
type.js
 â†“ 
action.js
 â†“
reducer.js
 â†“
implement reducer logic using our existing react state logic
 â†“
create store in store.js




*************************************************************************************
****************************   Phase 1 â€” Identify what goes to Redux  ***************

1. Redux m shift hone se pehle dekho , humara jo store hai usmai kon konsi state jaayegi 
    â€œOnly state that is global, shared, and meaningful across components goes to Redux.â€
    Is used by several components 
    Needs to survive navigation / refresh
    Needs to be editable from many places

2. UI / Ephemeral State (Redux âŒ) -->> inko humein redux mai nahi daalna hai 
   This is temporary UI behavior.
   Characteristics:
   Local to ONE component
   Exists only for user interaction
   Reset when component unmounts
   Does NOT represent real data
   No need to persist or share    

3. ğŸ¯ Redux Decision Checklist (Use this EVERY time)

Ask these 5 questions for any state:

1ï¸âƒ£ Is this used by more than one component?
2ï¸âƒ£ Does this represent real app data?
3ï¸âƒ£ Should this survive refresh or navigation?
4ï¸âƒ£ Will multiple actions modify this state?
5ï¸âƒ£ Will I ever need to debug / replay changes?

If 3 or more answers are YES â†’ Redux
Otherwise â†’ local state   

If itâ€™s data â†’ Redux
If itâ€™s behavior â†’ local state







*************************************************************************************
****************************    PHASE 2 - STATE SHAPE  ******************************

ğŸ”‘ Golden Principle of State Shape
Design state based on â€œwhat the app knowsâ€, not â€œwhat the UI looks likeâ€.







*************************************************************************************
****************************    PHASE 3 - ACTION  ******************************
ğŸ§  What is an â€œActionâ€ in Redux (in plain English)
An action answers one simple question:
â€œWhat just happened in the app?â€

NOT:
how it happened
not UI details
not implementation logic
Just the event.



Examples in real life:
â€œTask addedâ€
â€œTask deletedâ€
â€œTask title editedâ€
â€œTask marked completedâ€
Thatâ€™s it.


Key rule of Phase 3
Every place in your app where you currently call setTasks(...)
becomes a Redux action.
No exceptions.


Step 1: List all the ways your tasks change today
Look at your current props-based app.
You already have functions like:

handleAddTask
deleteTask
editTask
checkbox toggle

Each of these changes the tasks array.
So they must become Redux actions.

**********************   functions -> becomes -> actions ******************





*************************************************************************************
****************************  PHASE 4 â€” Writing reducers ****************************

A reducer is just:
A pure function that decides how state changes when an action happens.

Read that again.
It does NOT trigger events
It does NOT talk to UI
It does NOT call APIs
It does NOT mutate state

It only answers this question:
â“ â€œGiven the current state and an action, what should the NEW state be?â€

Phase 4 (Reducers) is the heart of Redux â€” and once this phase clicks, Redux stops feeling scary.

Every reducer follows this mental structure:
(currentState, action) â†’ newState




âœ… Reducer must be pure
Same input â†’ same output
No randomness
No side effects

âŒ Reducer must NOT:
Mutate existing state
Use setTimeout, fetch, localStorage
Change variables outside

âœ… Reducer MUST:
Return a new object / array
Leave untouched state as-is



ğŸ§± Step 1: Initial State
Reducer always needs a starting point.
For your app, the initial state is simply:
No tasks yet

Empty array
Conceptually:
initialState = {
  tasks: []
}
This matches your React useState([]).




ğŸ§± Step 2: Reducer Skeleton (Mental Model)
Every reducer follows this shape:

function reducer(state = initialState, action) {
  switch(action.type) {
    case ACTION_1:
      return updatedState

    case ACTION_2:
      return updatedState

    default:
      return state
  }
}


Why default: return state?
Because if Redux dispatches an unknown action,
state should not change.

Redux depends on immutability to:
Detect changes
Trigger re-renders
Enable time-travel debugging

So reducers always:
Create new arrays
Create new objects
No UI logic.
No prompts.
No validation.


